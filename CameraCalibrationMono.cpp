#include "opencv2/opencv.hpp"

/*
 * Objective: Show how to calibrate a single camera from either a live
 * video feed or a sequence of files.
 */


int main(int argc, const char * argv[]) {
    
    // Change this according to your chessboard size!
    cv::Size chessboardSize(5,4); // Size(w,h)
    
    // The captured frame, and a gray version for sub-pixel accuracy.
    cv::Mat frame, frameGray;
    
    // The number of frames that have been captured.
    int frameCount = 0;
    
    // Setup to capture live video frames.
    cv::VideoCapture cap(0);
    
    if (!cap.isOpened())
    {
        std::cout << "VideoCapture not able to open.";
        exit(1);
    }
    
    //    cap.set(CV_CAP_PROP_FRAME_WIDTH, 640);
    //    cap.set(CV_CAP_PROP_FRAME_HEIGHT, 480);
    
    // Show the frame dimensions.  The camera matrix should indicate a center
    // in the middle of the image.
    std::cout << "WIDTH " << cap.get(CV_CAP_PROP_FRAME_WIDTH) << "\n";
    std::cout << "HEIGHT " << cap.get(CV_CAP_PROP_FRAME_HEIGHT) << "\n";
    
    cv::Size imageSize(cap.get(CV_CAP_PROP_FRAME_WIDTH), cap.get(CV_CAP_PROP_FRAME_HEIGHT));
    
    // Record corresponding object and image points for multiple image captures.
    std::vector<std::vector<cv::Point2f> > imagePoints;
    std::vector<std::vector<cv::Point3f> > objectPoints;
    
    // Generated by the calibration algorithm.
    std::vector<cv::Mat> rvecs, tvecs;
    cv::Mat cameraMatrix = cv::Mat::eye(3,3,CV_64F);
    cv::Mat distCoeffs = cv::Mat::zeros(8,1,CV_64F);
    
    // The corner image points for one image capture.
    std::vector<cv::Point2f> imageCorners;
    
    // Generate a pattern for the object.
    std::vector<cv::Point3f> objectCorners;
    
    for (int r=0; r<chessboardSize.height; r++)
        for (int c=0; c<chessboardSize.width; c++)
            objectCorners.push_back(cv::Point3f(c, r, 0.0f)); // Point2f(x,y)
    
    int keyPressed;
    
    do
    {
        cap.read(frame);
        
        // Find the chessboard corners, to sub-pixel accuracy.
        bool patternFound = cv::findChessboardCorners(frame, chessboardSize, imageCorners);
        
        switch (keyPressed = cv::waitKey(1))
        {
            case 32:
                // Press space to capture a frame.
                if (patternFound)
                {
                    // Store the frame to file.
                    char filename[20];
                    sprintf(filename, "Frame%d.jpg", frameCount++);
                    cv::String s(filename);
                    std::cout << s  << std::endl;
                    
                    cv::imwrite(filename, frame);
                    
                    // Save the points for computation.
                    objectPoints.push_back(objectCorners);
                    imagePoints.push_back(imageCorners);
                    
                    // Compute sub-pixel accuracy, cornerSubPix requires grayscale.
                    cv::cvtColor(frame, frameGray, CV_BGR2GRAY);
                    
                    cv::cornerSubPix(frameGray, imageCorners, cv::Size(11,11), cv::Size(-1,-1),
                                     cv::TermCriteria(CV_TERMCRIT_EPS  + CV_TERMCRIT_ITER, 30, 0.1));
                    
                    // Use all captured frames to estimate the camera matrices.
                    cv::calibrateCamera(objectPoints, imagePoints, frame.size(), cameraMatrix, distCoeffs, rvecs, tvecs);
                    
                    std::cout << cameraMatrix << std::endl;
                    
                    // Flash GREEN if the picture contains chessboard corners.
                    frame = cv::Scalar(0,255,0);
                }
                else
                {
                    // Flash RED if the picture does NOT contain chessboard corners.
                    frame = cv::Scalar(0,0,255);
                }
                break;
                
            default:
                // If the pattern is found, but not capturing this frame, just show the corners.
                if (patternFound)
                {
                    cv::drawChessboardCorners(frame, chessboardSize, cv::Mat(imageCorners), patternFound);
                }
                break;
        }
        
        cv::imshow("Camera", frame);
        
        // Press ESC to exit.
    } while (keyPressed != 27);
    
    
    // Write results
    
    cv::FileStorage fs;
    fs.open("CameraMatrices.yaml", cv::FileStorage::WRITE);
    if (fs.isOpened())
    {
        fs << "cameraMatrix" << cameraMatrix;
        fs << "distCoeffs" << distCoeffs;
        fs.release();
    }
    
    // Compute some useful characteristics from the camera matrix.
    
    // Webcam:           Logitech C310
    // Specs:            http://support.logitech.com/en_us/product/hd-webcam-c310/specs
    // Field of View:    60 degrees
    // Focal Length:     4.4 mm
    // Optical Res:      1280 x 960 VGA
    
    // Sensor Size Info: http://pomeroyprinting.blogspot.com/2014/04/modifying-logitech-c310-hd-webcam.html
    // Sensor Size:      3.6 mm x 2.7 mm
    
    // inputs:
    double aperatureWidth = 3.6;
    double aperatureHeight = 2.7;
    
    // outputs:
    double fovx, fovy, focalLength, aspectRatio;
    cv::Point2d principalPoint;
    
    cv::calibrationMatrixValues(cameraMatrix, imageSize, aperatureWidth, aperatureHeight,
                                fovx, fovy, focalLength, principalPoint, aspectRatio);
    
    std::cout << "fovx: " << fovx << std::endl;
    std::cout << "fovy: " << fovy << std::endl;
    std::cout << "focalLength: " << focalLength << std::endl;
    std::cout << "principalPoint: " << principalPoint << std::endl;
    std::cout << "aspectRatio: " << aspectRatio << std::endl;
    
    return 0;
}
