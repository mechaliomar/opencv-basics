#include "opencv2/opencv.hpp"

/*
 * Objective: Show how to calibrate a stereo camera from either a live
 * video feed or a sequence of files.
 */


// If LIVE_VIDEO_FEED is defined, use a live video feed, otherwise
// read from files.
#define LIVE_VIDEO_FEED

// Change this according to your chessboard size!
static cv::Size chessboardSize(5,4); // Size(w,h)

// This mouse callback position is used to draw the epipolar line on the
// other image given the mouse location of the present (mouse over) image.
void mousePositionCallback(int event, int x, int y, int flags, void *userData)
{
    // std::cout << "Mouse: " << event << " " << x << " " << y << " " << flags << std::endl;
    
    // Simply populate the (x, y) coordinates of the mouse pointer and do
    // the calculations in the main function.
    ((cv::Point2f *) userData)->x = (float) x;
    ((cv::Point2f *) userData)->y = (float) y;
}

int main(int argc, const char * argv[]) {
    
    // The captured frame, and a gray version for sub-pixel accuracy.
    //    cv::Mat frameL, frameGrayL, frameR, frameGrayR;
    cv::Mat frameGrayL, frameGrayR;
    
    cv::Size imageSizeL, imageSizeR;
    
    // The number of frames that have been captured.
    int frameCount = 0;
    
    // Record corresponding object and image points for multiple image captures.
    std::vector<std::vector<cv::Point2f> > imagePointsL, imagePointsR;
    std::vector<std::vector<cv::Point3f> > objectPoints;
    
    // Generated by the stereo calibration algorithm.
    cv::Mat cameraMatrixL = cv::Mat::eye(3,3,CV_64F);
    cv::Mat distCoeffsL = cv::Mat::zeros(8,1,CV_64F);
    cv::Mat cameraMatrixR = cv::Mat::eye(3,3,CV_64F);
    cv::Mat distCoeffsR = cv::Mat::zeros(8,1,CV_64F);
    
    cv::Mat R, T, E, F;
    
    // The corner image points for one image capture.
    std::vector<cv::Point2f> imageCornersL, imageCornersR;
    
    // Generate a pattern for the object.
    std::vector<cv::Point3f> objectCorners;
    
    for (int r=0; r<chessboardSize.height; r++)
        for (int c=0; c<chessboardSize.width; c++)
            objectCorners.push_back(cv::Point3f(c, r, 0.0f)); // Pointef(x,y,z)
    
#ifdef LIVE_VIDEO_FEED
    
    cv::namedWindow("Camera");
    cv::startWindowThread();
    
    // Record the position of the mouse.  Start with a sentinal and update
    // the mouse position in the mousePoint callback function.
    cv::Point2f mousePosition(-1.0f, -1.0f);
    cv::setMouseCallback("Camera", mousePositionCallback, &mousePosition);
    
    // Setup to capture live video frames.
    cv::VideoCapture capL(0);
    cv::VideoCapture capR(1);
    
    if (!capL.isOpened() || !capR.isOpened())
    {
        std::cout << "VideoCapture not able to open.";
        exit(1);
    }
    
    capL.set(CV_CAP_PROP_FRAME_WIDTH, 720);
    capL.set(CV_CAP_PROP_FRAME_HEIGHT, 480);
    capR.set(CV_CAP_PROP_FRAME_WIDTH, 720);
    capR.set(CV_CAP_PROP_FRAME_HEIGHT, 480);
    
    // Show the frame dimensions.  The camera matrix should indicate a center
    // in the middle of the image.
    std::cout << "Left WIDTH " << capL.get(CV_CAP_PROP_FRAME_WIDTH)
    << " HEIGHT " << capL.get(CV_CAP_PROP_FRAME_HEIGHT) << std::endl;
    std::cout << "Right WIDTH " << capR.get(CV_CAP_PROP_FRAME_WIDTH)
    << " HEIGHT " << capR.get(CV_CAP_PROP_FRAME_HEIGHT) << std::endl;
    
    imageSizeL = cv::Size(capL.get(CV_CAP_PROP_FRAME_WIDTH), capL.get(CV_CAP_PROP_FRAME_HEIGHT));
    imageSizeR = cv::Size(capR.get(CV_CAP_PROP_FRAME_WIDTH), capR.get(CV_CAP_PROP_FRAME_HEIGHT));
    
    if (imageSizeL != imageSizeR)
    {
        std::cout << "Left and right images must be the same size." << std::endl;
        exit(1);
    }
    
    // Show the left and right cameras combined as one image by initializing a single
    // frame and splitting it into two Mat subsets.
    cv::Mat frame(imageSizeL.height, 2*imageSizeL.width, CV_8UC3);
    cv::Mat frameL = frame(cv::Rect(0,0, imageSizeL.width, imageSizeL.height));
    cv::Mat frameR = frame(cv::Rect(imageSizeL.width,0, imageSizeL.width, imageSizeL.height));
    
    
    int keyPressed;
    
    // Show epipolar lines.
    bool bShowEpipolar = true;
    
    do
    {
        capL.read(frameL);
        capR.read(frameR);
        
        // Find the chessboard corners, to sub-pixel accuracy.
        bool patternFound =
        cv::findChessboardCorners(frameL, chessboardSize, imageCornersL) &&
        cv::findChessboardCorners(frameR, chessboardSize, imageCornersR);
        
        switch (keyPressed = cv::waitKey(1))
        {
            case 'e':
                bShowEpipolar = !bShowEpipolar;
                break;
                
            case 32:
                // Press space to capture a frame.
                if (patternFound)
                {
                    std::cout << std::endl;
                    
                    // Store the frame to file.
                    char filename[20];
                    
                    {
                        sprintf(filename, "FrameL%d.jpg", frameCount);
                        cv::String s(filename);
                        std::cout << s << std::endl;
                        cv::imwrite(filename, frameL);
                    }
                    {
                        sprintf(filename, "FrameR%d.jpg", frameCount);
                        cv::String s(filename);
                        std::cout << s << std::endl;
                        cv::imwrite(filename, frameR);
                    }
                    
                    frameCount++;
                    
                    // Compute sub-pixel accuracy, cornerSubPix requires grayscale.
                    cv::cvtColor(frameL, frameGrayL, CV_BGR2GRAY);
                    cv::cvtColor(frameR, frameGrayR, CV_BGR2GRAY);
                    
                    cv::cornerSubPix(frameGrayL, imageCornersL, cv::Size(11,11), cv::Size(-1,-1),
                                     cv::TermCriteria(CV_TERMCRIT_EPS  + CV_TERMCRIT_ITER, 30, 0.1));
                    cv::cornerSubPix(frameGrayR, imageCornersR, cv::Size(11,11), cv::Size(-1,-1),
                                     cv::TermCriteria(CV_TERMCRIT_EPS  + CV_TERMCRIT_ITER, 30, 0.1));
                    
                    // Save the points for computation.
                    objectPoints.push_back(objectCorners);
                    imagePointsL.push_back(imageCornersL);
                    imagePointsR.push_back(imageCornersR);
                    
                    // Use all captured frames to estimate the camera matrices.
                    //                    cv::calibrateCamera(objectPoints, imagePoints, frame.size(), cameraMatrix, distCoeffs, rvecs, tvecs);
                    
                    // The default for the flags parameter is CV_CALIB_FIX_INTRINSIC which causes the
                    // camera matrices to remain as identity matrices.  Set it to 0 to get estimates
                    // for the camera matrices.
                    double reprojError = cv::stereoCalibrate(objectPoints, imagePointsL, imagePointsR,
                                                             cameraMatrixL, distCoeffsL, cameraMatrixR, distCoeffsR,
                                                             imageSizeL, R, T, E, F, 0);
                    
                    std::cout << cameraMatrixL << std::endl << cameraMatrixR << std::endl;
                    std::cout << T << std::endl;
                    std::cout << "reprojError " << reprojError << std::endl;
                    
                    // Flash GREEN if the picture contains chessboard corners.
                    frameL = cv::Scalar(0,255,0);
                    frameR = cv::Scalar(0,255,0);
                }
                else
                {
                    // Flash RED if the picture does NOT contain chessboard corners.
                    frameL = cv::Scalar(0,0,255);
                    frameR = cv::Scalar(0,0,255);
                }
                break;
                
            default:
                break;
        }
        
        // If the pattern is found, but not capturing this frame, just show the corners.
        if (patternFound)
        {
            cv::drawChessboardCorners(frameL, chessboardSize, cv::Mat(imageCornersL), patternFound);
            cv::drawChessboardCorners(frameR, chessboardSize, cv::Mat(imageCornersR), patternFound);
        }
        
        // EPIPOLAR LINES
        // ==============
        
        // Show the epipolar lines if desired.
        if (bShowEpipolar && F.cols == 3 && F.rows == 3 && mousePosition.x >= 0.0 && mousePosition.y >= 0.0)
        {
            // Determine if the mouse is in the left (0) image or right (1) image.
            int whichImage = (int) mousePosition.x / imageSizeL.width;
            
            // Find the mouse position relative to the left or right camera frame (not the combined frame).
            std::vector<cv::Point2f> points;
            
            cv::Point point(mousePosition);
            point.x -= whichImage * imageSizeL.width;
            points.push_back(point);
            
            // The output line, expressed as a, b and c in ax + by + c = 0.
            std::vector<cv::Point3f> lines;
            
            // computeCorrespondEpilines expects whichImage=1 (left) or =2 (right).
            cv::computeCorrespondEpilines(points, whichImage+1, F, lines);
            
            // If we got a result, show the epiline.
            if (lines.size() >= 1)
            {
                // Determine the endpoints of the epiline.
                cv::Point2f pt1(0, -1), pt2(imageSizeL.width-1, -1);
                
                // Only if possible!
                if (lines[0].y != 0.0f)
                {
                    pt1.y = (-lines[0].z - lines[0].x * pt1.x) / lines[0].y;
                    pt2.y = (-lines[0].z - lines[0].x * pt2.x) / lines[0].y;
                    
                    // Draw the line in the OTHER frame.
                    pt1.x += ((whichImage + 1) % 2) * imageSizeL.width;
                    pt2.x += ((whichImage + 1) % 2) * imageSizeL.width;
                    
                    cv::circle(frame, mousePosition, 4, cv::Scalar(0,255,0), -1);
                    cv::line(frame, pt1, pt2, cv::Scalar(0,255,0));
                }
                
                std::cout << lines[0].x << " " << lines[0].y << " " << lines[0].z << std::endl;
                std::cout << pt1 << " " << pt2 << std::endl;
            }
        }
        
        cv::imshow("Camera", frame);
        //        cv::imshow("CameraL", frameL);
        //        cv::imshow("CameraR", frameR);
        
        // Press ESC to exit.
    } while (keyPressed != 27);
#else
    while (1)
    {
        // Read the frame from file.
        char filename[20];
        sprintf(filename, "Frame%d.jpg", frameCount++);
        cv::String s(filename);
        
        // Try to read the file.  If not, then stop reading files.
        frame = cv::imread(filename);
        if (frame.cols == 0 || frame.rows == 0)
            break;
        
        std::cout << s  << std::endl;
        
        imageSize = frame.size();
        
        // Find the chessboard corners, to sub-pixel accuracy.
        bool patternFound = cv::findChessboardCorners(frame, chessboardSize, imageCorners);
        
        // Press space to capture a frame.
        if (patternFound)
        {
            cv::drawChessboardCorners(frame, chessboardSize, cv::Mat(imageCorners), patternFound);
            cv::imshow("Camera", frame);
            cv::waitKey(500);
            
            // Compute sub-pixel accuracy, cornerSubPix requires grayscale.
            cv::cvtColor(frame, frameGray, CV_BGR2GRAY);
            
            cv::cornerSubPix(frameGray, imageCorners, cv::Size(11,11), cv::Size(-1,-1),
                             cv::TermCriteria(CV_TERMCRIT_EPS  + CV_TERMCRIT_ITER, 30, 0.1));
            
            // Save the points for computation.
            objectPoints.push_back(objectCorners);
            imagePoints.push_back(imageCorners);
        }
        
        // Use all captured frames to estimate the camera matrices.
        cv::calibrateCamera(objectPoints, imagePoints, frame.size(), cameraMatrix, distCoeffs, rvecs, tvecs);
        
        std::cout << cameraMatrix << std::endl;
    };
#endif
    
    // Write results
#if 0
    cv::FileStorage fs;
    fs.open("CameraMatrices.yaml", cv::FileStorage::WRITE);
    if (fs.isOpened())
    {
        fs << "cameraMatrix" << cameraMatrix;
        fs << "distCoeffs" << distCoeffs;
        fs << "chessboardSize" << chessboardSize;
        fs << "imageSize" << imageSize;
        fs.release();
    }
    
    // Compute some useful characteristics from the camera matrix.
    
    // Webcam:           Logitech C310
    // Specs:            http://support.logitech.com/en_us/product/hd-webcam-c310/specs
    // Field of View:    60 degrees
    // Focal Length:     4.4 mm
    // Optical Res:      1280 x 960 VGA
    
    // Sensor Size Info: http://pomeroyprinting.blogspot.com/2014/04/modifying-logitech-c310-hd-webcam.html
    // Sensor Size:      3.6 mm x 2.7 mm
    
    // inputs:
    double aperatureWidth = 3.6;
    double aperatureHeight = 2.7;
    
    // outputs:
    double fovx, fovy, focalLength, aspectRatio;
    cv::Point2d principalPoint;
    
    cv::calibrationMatrixValues(cameraMatrix, imageSize, aperatureWidth, aperatureHeight,
                                fovx, fovy, focalLength, principalPoint, aspectRatio);
    
    std::cout << "fovx: " << fovx << std::endl;
    std::cout << "fovy: " << fovy << std::endl;
    std::cout << "focalLength: " << focalLength << std::endl;
    std::cout << "principalPoint: " << principalPoint << std::endl;
    std::cout << "aspectRatio: " << aspectRatio << std::endl;
#endif
    return 0;
}
